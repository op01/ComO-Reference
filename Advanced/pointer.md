Pointer
=======
pointer เป็นตัวแปรอีกประเภทนึงที่เก็บค่าที่อยู่ของตัวแปรอื่น ก่อนอื่นเราต้องรู้จักที่อยู่ตัวแปรกันก่อน
Address
-------
ตัวแปรแต่ละตัวที่เราประกาศไว้จะอยู่ใน RAM ซึ่งก็ต้องมีที่อยู่ใน RAM เป็นของตัวเอง เวลาทำอะไรจะได้ทำถูกตัว
```cpp
int a=5;
printf("%p",&a);
```
จากโค้ดนี้ผลลัพธ์จะออกมาคล้ายๆ `000000000023fe48` ในระบบ 64bit หรือ `0023fe48` ในระบบ 32bit ซึ่งก็คือที่อยู่ใน RAM ของตัวแปร a นั้นเอง

- %p คือ format ของที่อยู่ (Memory address)
- &a คือ ที่อยู่ของตัวแปร a 
- & คือ Address-of operator

สรุปว่าใช้ operator `&` (ระวังปนกับ bitwise-and) ตามด้วยชื่อตัวแปร จะกลายเป็นที่อยู่ของตัวแปรนั้น ไม่ว่าตัวแปรนั้นจะเป็นชนิดอะไรก็ตาม เช่น

```cpp
int a=5;
float b=10;
string str = "Hello World";
printf("%p , %p , %p",&a,&b,&str); // print variable address
```

Declaring pointer
-------------
pointer เป็นตัวแปรประเภทหนึ่ง ที่จะเก็บ **ตำแหน่งในเมมโมรี** ของตัวแปรอื่นๆไว้ เวลาประกาศใช้ ชื่อตัวแปรเป้าหมาย ตามด้วย `*`

```cpp
int num;
int* ptr=&num; // ptr เป็น pointer ที่เก็บตำแหน่งในเมมโมรี ของ num
printf("%p",ptr);
float f;
float* fptr = &f; // fptr เป็น pointer ของ (float) ที่ชื่อ f
float** ffptr = &fptr; // ffptr เป็น pointer ของ (float*) ที่ชื่อ fptr

```

ประเภทของ pointer กับตัวแปรที่มันชี้ต้องตรงกัน ถึงแม้ว่า pointer จะมีขนาดเท่ากัน (เป็นเลขบอก memory address เหมือนกัน) แต่ก็ต้องรู้ว่าข้อมูลที่ pointer ตัวนี้ชี้มีขนาดกี่ byte เพื่อเวลาแปลงมาใช้ จะได้รู้ว่าเป็นตัวแปรอะไรกันแน่ (จริงๆแล้วเราใช้ void* แล้ว cast เอาได้ แต่ไม่ควรอย่างยิ่ง เพราะถ้าเกิด error ขึ้นมาจะแก้ได้ยาก และโอกาสเกิดสูง)

Dereference
-----------
เมื่อเราได้ pointer มาแล้ว ถ้าเราต้องการใช้ตัวที่ pointer ชี้อยู่ ไม่ใช้ตัว pointer เอง ให้ใช้ตัว `*` ตามด้วยชื่อ pointer นั้น
```cpp
int num=1;
int* ptr=&num;
printf("num=%d\n",num); // => 1
*ptr = 5;
printf("num=%d\n",num);// => 5
// reference & dereference can be chained
printf("%d",*&*&*&num); // => 5 (เพื่ออะไร?)

struct Person
{
	char name[10];
    int age;
};
Person john;
john.age = 18;
Person* johnptr=&john // pointer of struct!
(*johnptr).age = 19; // dereferenced and access member
johnptr->age = 20; //struct pointer member can also be accessed this way
```
Pointer to pointer
------------------
แน่นอนว่า potiner ก็เป็นตัวแปรเหมือนกัน เพราะฉะนั้นก็อาจถูกชี้โดย pointer ตัวอื่นได้เช่นกัน การประกาศ pointer ชี้กันเองแบบนี้ทำโดย `*` ไปเรื่อยๆ
```cpp
int num;
int* pnum=&num;
int** ppnum=&pnum;
int*** pppnum=&ppnum'
```
Memory Allocation
-----------------
เรารู้มาแล้วว่าเวลาเราประกาศตัวแปรคอมพิวเตอร์จะไปจองพื้นที่สำหรับตัวแปรนั้นให้ และเมื่อหมด scope ของตัวแปรนั้นก็จะทำลายและคืนพื้นที่ให้ แต่ถ้าเราต้องการพื้นที่โดยไม่ขึ้นกับตัวแปร เราต้องใช้ `malloc(size)` ซึ่งอยู่ใน `stdlib.h`
```cpp
int* ptr=(int*)malloc(sizeof(int));
free(ptr);
```
- `sizeof(int)` คือขนาดของข้อมูลชนิด int
- `malloc(size)` คือจองพื้นที่ขนาด size byte(s) ซึ่งจะคืนค่าเป็นที่อยู่ที่จองให้
- `(int*)` คือการแปลง pointer ที่คืนเป็นรูปแบบ int\* (int pointer)
- `free(ptr)` คืนพื้นที่หลังใช้งานเสร็จ

Pointer and Array
-----------------
อาเรย์ที่เราเรียนมาแล้วนั้นที่จริงมันคือตัวแปร pointer นั้นเอง
```cpp
int *arr=(int*)malloc(sizeof(int)*n);
arr[0]=1000007;
```
Pass by value vs Pass by pointer
--------------------------------
สมมติเราต้องการเขียนฟังชั่น swap โดยทำหน้าที่สลับข้อมูล 2 ตัว
```cpp
void swap(int a,int b)
{
	int temp=a;
    a=b;
    b=tmp;
}
int x=10,y=20;
swap(x,y);
```
ถ้าเราเขียนแบบนี้เวลาใช้งาน  จะไม่เกิดอะไรขึ้น เพราะว่าที่ส่งเข้าไปในฟังชั่นคือ "ค่า"  ซึ่งเมื่อสลับค่าในฟังชั่นนั้นแล้วค่านั้นก็หายไป เราจึงต้องใช้ pointer มาช่วย
```cpp
void swap(int* a,int* b)
{
	int tmp=*a;
    *a=*b;
    *b=tmp;
}
int x=10,y=20;
swap(&x,&y);
```
นั้นก็คือส่งที่อยู่ของตัวแปรที่เราต้องการสลับไป ในฟังชั่นเราใช้ `*` dereference จึงได้ตัวแปร x,y จริงๆ แล้วเราก็ทำการสลับปกติ

Example
-------
สมมติยังไม่เข้าใจว่า pointer คืออะไร ลองมาดูตัวอย่างนี้กัน
```cpp
int a = 100;
```
แน่นอนว่าตัวแปรนี้จะต้องนำไปเก็บไว้ใน RAM แน่นอน เราถึงเรียกใช้มันกลับมาได้ ซึ่งใน RAM มีข้อมูลมากมายมหาศาล ซึ่งต้องมีที่อยู่ของมันเอง (ตัวอย่างนี้ใช้เลขสมมติ)
```
RAM :
...
[3200010] a=100
...
```
จากตัวอย่าง ตัวแปร a มีตำแหน่งใน RAM ที่ 3200010 (เนื่องจาก int มา 4 bytes ดังนั้นจริงๆ a จะอยู่ตั้งแต่ 3200010 - 3200013 แต่เราเอาแค่จุดเริ่มก็พอ)

ถ้าเราเรียกใช้ a จากจุดอื่น คอมจะรู้ได้ทันทีว่าเราจะใช้ข้อมูลจากตำแหน่ง 3200010 นะ (ถึง 3200013 เพราะคอมรู้ว่า int มี 4 bytes)

```cpp
int* ptr = &a;
```

ใน RAM ก็จะมีตัวแปรชื่อ ptr ขึ้นมาอีก
```
RAM :
...
[3200010] a=100
...
[3200030] ptr=3200010 (ตำแหน่ง a)
...
```

เมื่อเรา dereference ptr มา คอมจะเข้าใจว่าเราจะใช้ตัวแปรที่ตำแหน่งนั้นๆแทน (ใช้ a นั่นแหละ)
```cpp
a += 10; // เรียกใช้ตัวแปรที่ตำแหน่ง 3200010 คือ a
*ptr += 10; // เรียกใช้ตัวแปรที่ ptr ชี้อยู่ คือตัวแปรที่ตำแหน่ง 3200010 คือ a
```

แล้ว pointer ของ pointer ก็ประมาณ
```
RAM :
...
[3200010] a=100
...
[3200030] ptr=3200010 (ตำแหน่ง a)
...
[3200070] pptr=3200030 (ตำแหน่ง ptr)
```

```
*ptr คือ *3200010 -> a
**pptr คือ *(*3200030) -> *ptr -> *3200010 -> a
```

ประโยชน์หลักๆของ pointer ก็คือเวลาใช้ฟังก์ชันเพื่อเปลี่ยนค่าตัวแปร และประกาศ array

Pass by Reference
-----------------
```cpp
void swap(int* a,int* b)
{
	int tmp=*a;
    *a=*b;
    *b=tmp;
}
int x=10,y=20;
swap(&x,&y);
```
ใน C++ เรามีสิ่งพิเศษที่เรียกว่า pass By Reference อยู่ ซึ่งคือการบอกว่าในฟังก์ชันนี้ ให้ส่งตัวแปรเข้าไปจริงๆนะ ไม่เอาแค่ค่า จากตัวอย่างข้างบน เราเขียนได้เป็น 
```cpp
void swap(int& a,int& b) // int& บอกว่าส่งเป็น reference มานะ อย่าส่งแต่ค่า มา
{
	int tmp=a;
    a=b;
    b=tmp;
}
int x=10,y=20;
swap(x,y);
```