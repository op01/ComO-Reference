Binary Search
=======
ใช้หาข้อมูล จากชุดข้อมูลที่มีการเรียงลำดับอยู่ เช่น ถามว่าจาก [1,5,9,10,15,18] มีเลข 10 อยู่หรือไม่ และประยุกต์ได้อีกหลากหลาย

Naive
--------
ใช้ for loop เช็คตั้งแต่ตัวแรกถึงตัวสุดท้าย O(N)

```cpp
bool search(int* arr,int N,int num)
{
	for(int i = 0;i < N;i++) {
    	if(arr[i] == num) return true;
    }
    return false;
}
```
Binary search จะใช้เวลาแค่ O(log N)

How does it work ?
------------------
สมมติว่าเราเปิดพจนานุกรม (เป็นตัวอย่างที่ classic มากๆ) พจนานุกรมนั้นเรียงจากตัว a-z ให้แล้ว สมมติจะหาคำว่า monopoly เรารู้ว่า m อยู่กลางๆ เราก็เปิดไปตรงกลางเลย เจอว่าเป็นตัว b เรารู้ว่า m มาหลัง b ดังนั้นเราก็จะไปเปิดอีกครึ่งนึงของข้างหลังแทน เพราะเรา**แน่ใจ**ได้ว่ามันจะไม่อยู่ครึ่งแรกแน่นอน สมมติเปิดมาได้ตัว x เราแน่ใจว่าไม่อยู่หลังจากนี้ เราก็เปิดมาหน้าๆหน่อย จนกว่าจะเจอ

พูดง่ายๆ สมมติพจนานุกรมมี 100 หน้า เราเปิดหน้า 50 เจอเป็นตัว b แสดงว่า คำว่า monopoly ต้องอยู่ในหน้า 51-100 แน่นอน เราเปิดอีกครึ่งคือหน้า 75 เป็นตัว x แสดงว่า monopoly ต้องอยู่หน้า 51-74 แน่นอน อะไรประมาณนี้

สิ่งสำคัญของ binary search คือข้อมูลต้องเรียงกันมา หรืออะไรสักอย่าง ที่เรารู้ได้ว่าจากตรงนี้ ข้อมูลเราจะอยู่ซ้ายหรือขวา

สรุปก็คือ เปิดตรงกลาง ถ้าน้อยกว่าค่าที่ต้องการ (แสดงว่าค่าที่ต้องการอยู่ข้างหลัง) ก็ไปดูซีกหลังแทน แต่ถ้ามากกว่า ก็ไปดูซีกหน้า วนไปเรื่อยๆ

Pseudo Code
-----------
```
binarySearch(array,left,right,target) :
	if(left > right) return false // หาไม่มีวันเจอแน่
	middle = (laft+right)/2
    if(array[middle] < target) :
    	return binarySearch(array,middle+1,right,target) // ขอบซ้ายคือหน้าถัดไป
    if(array[middle] > target) :
    	return binarySearch(array,left,middle-1,target)
    if(array[middle] == target) :
    	return true; // เจอแล้ว
```
พวก middle left right ก็คือขอบเขตต่างๆ เช่น หน้า 1 - 100 คือ left=1 , right=100 เปิดกลางคือ middle=50 เจอว่าอยู่ซีกหลัง เราก็จะหาที่ 51-100 แทน หรือถ้าอยู่ซีกหน้าก็จะเป็น 1-49

psuedo code เป็น recursive เพื่อให้เข้าใจง่าย แต่เวลาเขียนจริงๆให้เปลี่ยนเป็น loop แทนจะเร็วกว่า

C++ Code
--------
```cpp
bool binarySearch(int* arr,int n,int targ)
{
	// have page 0 to (n-1)
    int l = 0;
    int r = n-1;
    while(l<=r) {
    	int m = (l+r)/2;
        if(arr[m]<targ) l=m+1;
        if(arr[m]>targ) r=m-1;
        if(arr[m]==targ) return true;
    }
    return false;
}
```

Use in
------
** binary search ใช้เยอะมากๆๆๆๆๆๆๆๆๆ **

- หาตามปกติว่ามีตัวแปรนี้อยู่ใน array รึเปล่า
- ดัดแปลง search นิดนึง หาว่า ตัวแรกที่มากกว่าตัวนี้คือเท่าไหร่
- ใช้หาได้ว่า สามารถ ... ได้มากที่สุดเท่าไหร่ ที่ยังโอเคอยู่ หรือเทคนิค binary search คำตอบ คือลองดูว่าคำตอบนี้สามารถทำตามคำถามได้หรือไม่ ถ้าได้ ลองเพิ่ม/ลดคำตอบดู ดูว่ายังได้รึเปล่า binary search ไปเรื่อยๆ
