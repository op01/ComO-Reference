Exponentiation by squaring
=======
Exponentiation คือการยกกำลัง ตัวอย่างเช่น 2^4 = 2&#42;2&#42;2&#42;2 = 16 , 2^10 = 1024 เป็นต้น

Naive
--------
ใช้ for loop คูณเข้าไปจนครบ ใช้เวลา O(N) สำหรับ b^N

**สมมติให้ int ของเราสามารถเก็บค่าได้ไม่อั้น**
```cpp
int power(int base,int N)
{
	int answer = 1;
    for(int i = 0;i < N;i++) {
    	answer *= base;
    }
    return answer;
}
```
Exponentiation by squaring จะใช้เวลาแค่ O(log N)

How does it work ?
------------------
หลักการนั้นเข้าใจค่อนข้างง่าย ตัวอย่างเช่น เราต้องการหา 2^10 ถ้าเราคูณธรรมดาก็ใช้ 10 ครั้ง แต่เราใช้สมบัติอย่างนึงขึ้นมา คือเราแบ่ง 2^10 เป็น 2^5 * 2^5 หรือก็คือ (2^5) ^ 2 จะเห็นว่าเราแค่หา 2^5 ให้ได้ แล้วเอามายกกำลัง 2 อีกครั้ง ก็ได้ 2^10 แล้ว ทำแบบนี้คูณแค่ 6 ครั้งเอง แล้ววิธีหา 2^5 นั้นก็ใช้การ recursive ทำไปเรื่อยๆ

ถ้า N เป็นจำนวนคี่ เช่น 2^11 ก็ให้หา 2^10 มาก่อน แล้วคูณ 2 เข้าไป ก็จะได้ 2^11 (2^11 = (2^10) * 2) เราก็ใช้ recursive หา 2^10

สรุปคือ b^N ถ้า N เป็นจำนวนคู่ แบ่งครึ่ง หาคำตอบมาครึ่งหนึ่งด้วยวิธีการ recursive แล้วยกกำลัง 2 เข้าไป แต่ถ้า N เป็นจำนวนคี่ ก็หาของ N-1 มา แล้วคูณ b เข้าไป

Pseudo Code
-----------
```
power(base,n) : // find base^n
	if(n==0) :
    	return 1
       
    if(n is even) :
    	halfPower = power(base,n/2)
        return halfPower*halfPower // halfPower^2
    else :
    	return power(base,n-1)*base
```
ระวัง ตรง halfPower ถ้าเขียนไม่ดีสุดท้ายจะกลายเป็น O(N) เหมือนเดิม
```
...
if(n is even) :
	return power(base,n/2) * power(base,n/2); // เขียนแบบนี้ สุดท้ายก็กลับเป็น O(N) เหมือนเดิม
...
```

C++ Code
--------
```cpp
int power(int b,int n)
{
	if(n==0) return 1;
    if(n%2==0) {
    	int half = power(b,n/2);
        return half*half;
    }
    else return power(b,n-1);
}
```

Use in
------
- การยกกำลังเลขตามปกติ ก็คงไม่ช่วยมากเท่าไหร่เพราะยังไงก็ยกกำลังได้ไม่มากก็เกิน long long แล้ว
- การยกกำลังแล้ว mod จะช่วยได้พอควร เช่น 2^100000000 % 9 เราก็ประยุกต์เอา mod เข้าไปใส่ด้วย แก้นิดเดียวก็ได้
- ที่ช่วยเยอะที่สุดคือการยกกำลัง matrix โดยปกติ matrix คูณกัน 2 ตัวก็ใช้เวลา O(N^3) แล้ว (เมื่อ matrix มีขนาด N &#42; N แต่ถ้าใช้ algorithm ฉลาดๆอีก ก็จะเป็น O(N^ 2 กว่าๆ) ) ถ้าเอามายกกำลังกันอีกไม่ทันแน่นอน