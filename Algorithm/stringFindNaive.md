String Finding - Naive
=======
เป็นการหาว่ามีคำ B อยู่ในข้อความยาวๆ A หรือไม่ (เหมือนกับเวลาเราใช้คำสั่งค้นหา)

Naive
--------
การหาแบบนี้ จะใช้เวลา O(AB) เมื่อ A คือความยาวข้อความ และ B คือความยาวของข้อความที่ต้องการค้นหา ถ้าหลักการแบบง่ายๆเลยก็คือ สมมติ B ยาว 10 ตัว เราก็เช็ค A ตัวที่ 1-10 ว่าตรงรึเปล่า ไม่ตรงเช็ค 2-11 , 3-12 ไปเรื่อยๆ จนกว่าจะเจอตัวที่ตรง

```
for(int i = 0;i <= A.size()-B.size();i++) {
	if(A.substr(i,B.size()) == B) {
    	// Found !
    }
}
```

ก็จะใช้เวลา O(A) * O(B) = O(AB)

How does it work ?
------------------
เราจำเป็นต้องเช็ค O(AB) ถึงจะได้คำตอบที่ถูกต้อง (แต่หลังๆจะมีวิธีฉลาดๆ) แต่อาจจะมีบางคนถามว่า แล้วแบบนี้ใช้ไม่ได้เหรอ 
```
int bChecking = 0;
for(int i = 0;i < A.size();i++) {
	if(A[i] == B[bChecking]) {
    	bChecking++;
        if(bChecking >= B.size()) {
        	// Found !
        }
    }
    else {
    	bChecking = 0;
    }
}
```

คือเก็บว่าตอนนี้เราจะเช็ค B ตัวที่ 0 นะ ไล่ใน A ไปเรื่อยๆ สมมติว่าเจอตรงกัน เราบอกให้ต่อไปเช็คกับ B ตัวที่ 1 2 3 ไปเรื่อยๆ ถ้าครบก็คือเจอ แต่ถ้าเจอตัวที่ไม่ใช่ ก็กลับมาเช็คกับ B ตัวที่ 0

วิธีนี้เหมือนจะดี และใช้ O(A) แต่ว่าจะมีบางกรณีที่ผิด เช่น `A="aaab"` `B="aab"` เพราะอะไรลองไปคิดเล่นๆได้ (มันจะประมาณว่า aa ตรง แต่ตัวต่อไปไม่ตรง เลยรีเซ็ตเป็น 0 แต่จริงๆ a ตัวหลังมันไปเป็นตัวแรกของคำที่ต้องการอีกด้วย)

Pseudo Code
-----------
```
for(int i = 0;i <= A.size()-B.size();i++) {
	if(A.substr(i,B.size()) == B) {
    	// Found !
    }
}
```

หรือถ้าเราใช้ฉลาดกว่านี้อีกนิด ไว้เจอตัวแรกตรงกัน ค่อยเช็คตัวหลังๆ ถ้าไม่ตรง กลับไปตรงแรกแล้วเดินตามปกติ
```
for(int i = 0;i <= A.size()-B.size();i++) :
	if A[i] == B[0] :
    	// ตัวแรกตรงกัน เช็คต่อไป
        for j from 1 to B.size :
        	if A[i+j] != B[j] :
            	// ไม่ใช่
                
        // ถ้าสมมติว่าข้างบนเช็คผ่านมาหมด (ไม่เข้าตรงไม่ใช่) ก็แสดงว่าเจอแล้ว
```
C++ Code
--------
```cpp
bool stringSearch(string A,string B)
{
	for(int i = 0;i <= A.size()-B.size();i++) {
        if(A[i] == B[0]) {
            bool realMatch = true;
            for(int j = 1;j < B.size();j++) {
                if(A[i+j] != B[j]) {
                    realMatch = false;
                    break;
                }
            }
            if(realMatch) {
                // Found !
                return true;
            }
        }
    }
    return false;
}
```

Use in
------

String search ก็ออกโจทย์หลายข้อมาก ในระดับง่ายๆก็จะใช้วิธีนี้ได้ แต่ถ้ายากขึ้นไปจะออกให้ใช้วิธีฉลาดๆกว่านี้
